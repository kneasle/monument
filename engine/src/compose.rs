use std::{cmp::Ordering, sync::Arc};

use shortlist::Shortlist;

use crate::{
    graph::{Graph, NodeId},
    Engine,
};

/// The mutable data required to generate a composition.  Each worker thread will have their own
/// `EngineWorker` struct (but all share the same [`Engine`]).
#[derive(Debug)]
pub(crate) struct EngineWorker {
    thread_id: usize,
    /// The in-memory [`Graph`] of [`Node`]s
    graph: Graph<NodePayload>,
    /// A `Shortlist` of found compositions
    shortlist: Shortlist<Comp>,
    /// Which links where chosen after each node.  These are indices into the `links` field on each
    /// `Segment`.  Therefore, this is cheap to track during the composing loop and reconstruction
    /// a human-friendly representation just requires a traversal of the [`Engine`]'s [`Layout`].
    comp_prefix: Vec<usize>,
}

impl EngineWorker {
    /// Creates a new `EngineWorker`
    pub fn compose(engine: Arc<Engine>, thread_id: usize) {
        let mut worker = EngineWorker {
            thread_id,
            graph: Graph::from_engine(&engine, |node_id| NodePayload::new(node_id, &engine)),
            shortlist: Shortlist::new(engine.config.num_comps),
            comp_prefix: Vec::new(),
        };
    }
}

/// The payload stored in each [`Node`] in the [`Graph`]
#[derive(Debug, Clone)]
pub struct NodePayload {
    /// The number of rows in this node
    length: usize,
    /// The music score generated by this node
    score: f32,
}

impl NodePayload {
    fn new(node_id: &NodeId, engine: &Engine) -> Self {
        let seg_table = engine.get_seg_table(node_id.seg_id);
        Self {
            length: seg_table.length,
            score: seg_table.music.evaluate(&node_id.row),
        }
    }
}

/// A completed composition
#[derive(Debug, Clone)]
pub struct Comp {
    pub starting_node: usize,
    pub calls: Vec<usize>,
    pub length: usize,
    pub score: f32,
}

impl Comp {
    #[allow(dead_code)]
    fn to_string(&self, engine: &Engine) -> String {
        let mut string = format!("(len: {}, score: {}) ", self.length, self.score);

        let mut current_seg_id = engine.start_nodes[self.starting_node].seg_id;
        for &link_ind in &self.calls {
            let link = &engine.get_seg_table(current_seg_id).links[link_ind];
            string.push_str(&link.display_name);
            current_seg_id = link.end_segment;
        }

        string
    }
}

impl PartialOrd for Comp {
    #[inline(always)]
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.score.partial_cmp(&other.score)
    }
}

impl Ord for Comp {
    #[inline(always)]
    fn cmp(&self, other: &Self) -> Ordering {
        self.partial_cmp(other).unwrap_or(Ordering::Equal)
    }
}

impl PartialEq for Comp {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        self.score == other.score
    }
}

impl Eq for Comp {}

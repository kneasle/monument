use std::ops::{Add, AddAssign};

use bellframe::{music::Regex, Row, RowBuf};
use itertools::Itertools;

/// A class of music that Monument should care about
#[derive(Debug, Clone)]
pub struct MusicType {
    pub regexes: Vec<Regex>,
    pub weight: f32,
}

impl MusicType {
    /// Compute the score of a sequence of [`Row`]s
    pub fn score<'r>(&self, rows: impl IntoIterator<Item = &'r Row>) -> f32 {
        let mut num_matches = 0usize;
        for row in rows.into_iter() {
            for regex in &self.regexes {
                if regex.matches(row) {
                    num_matches += 1;
                }
            }
        }
        // Each match is given `self.weight`
        num_matches as f32 * self.weight
    }
}

/// A breakdown of the music generated by a composition
#[derive(Debug, Clone)]
pub struct Score {
    pub(crate) score: f32,
    /// The number of occurrences of each [`MusicType`] (the list of music types is stored in the
    /// [`Engine`] singleton).
    pub(crate) breakdown: Vec<usize>,
}

impl Score {
    /// Creates the `Score` of 0 (i.e. the `Score` generated by no rows).
    pub fn zero(num_music_types: usize) -> Self {
        Self {
            score: 0f32,
            breakdown: vec![0; num_music_types],
        }
    }

    /// Returns the `Score` generated by a sequence of [`Row`]s, transposed by some course head.
    pub fn from_rows<'r>(
        rows: impl IntoIterator<Item = &'r Row>,
        course_head: &Row,
        music_types: &[MusicType],
    ) -> Self {
        let mut temp_row = RowBuf::empty();
        let mut breakdown = vec![0; music_types.len()];
        // For every (transposed) row ...
        for r in rows {
            course_head.mul_into_buf(r, &mut temp_row).unwrap();
            // ... for every music type ...
            for (num_instances, ty) in breakdown.iter_mut().zip_eq(music_types) {
                // ... count the number of instances of that type of music
                for regex in &ty.regexes {
                    if regex.matches(&temp_row) {
                        *num_instances += 1;
                    }
                }
            }
        }

        Self {
            score: breakdown
                .iter()
                .zip_eq(music_types)
                .map(|(&num_instances, ty)| num_instances as f32 * ty.weight)
                .sum(),
            breakdown,
        }
    }
}

impl Add for &Score {
    type Output = Score;

    /// Combines two [`Score`]s to create one [`Score`] representing both `self` and `rhs`.
    ///
    /// # Panics
    ///
    /// Panics if the number of [`MusicType`]s in `rhs` is different to that of `self`.
    fn add(self, rhs: &Score) -> Self::Output {
        Score {
            score: self.score + rhs.score,
            breakdown: self
                .breakdown
                .iter()
                .zip_eq(rhs.breakdown.iter())
                .map(|(a, b)| a + b)
                .collect_vec(),
        }
    }
}

impl AddAssign<&Score> for Score {
    /// Combines the scores from another [`Score`] into `self` (so that `self` now represents the
    /// score generated by `self` and the RHS).
    ///
    /// # Panics
    ///
    /// Panics if the number of [`MusicType`]s in `rhs` is different to that of `self`.
    fn add_assign(&mut self, rhs: &Score) {
        self.score += rhs.score;
        for (a, b) in self.breakdown.iter_mut().zip_eq(rhs.breakdown.iter()) {
            *a += *b;
        }
    }
}
